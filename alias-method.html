<!DOCTYPE html>
<html lang="en">

<head>
    <title>The Alias Method for Fast Weighted Random</title>
    <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
</head>

<body>
    <div class="container">
<header>
    <a href="/">home</a>
</header>
<div class="row">
 <div class="col-md-8">
  <h1>The Alias Method for Fast Weighted Random</h1>
  <label>Posted on <strong>25 June 2017</strong></label>
  <style>
thick.thicker {
    font-weight: 900;
}
</style>

<p><strong><text class = "thick">Lets say you have a bag with 2 orange marbles, 2 blue marbles and 2 green marbles</text>.</strong> You draw one marble out of the bag. The probability of drawing any color marble is 1/3. This is called a uniform discrete distribution. It's easy to draw from this distribution with a computer. Computers can generate uniform pseudo random numbers in constant time so all you would have to do is generate a number from 1 to 3 and map it to a color of marble depending on the result. This can be done in constant time for any arbitrary number of colors as long as there are the same number of each color of marble.<br>
<br>
<strong>But now let's try a slightly different problem.</strong> Let's take a bag with 1 orange marble, 2 blue marbles and 4 green marbles. This distribution is a general discrete distribution. Clearly we can't tackle this exactly the same way as before. One simple adjustment we could make is to generate a random number between 1 and 7 and map it to 7 boxes. We could put a marble in each box and assign a orange marble to one box, blue marbles to two boxes and green marbles to four boxes. We then lookup the box which corresponds to the number we generate and check which kind of marble it has. This generates the correct distribution.<br>
<br>
<strong>Finally now let's look at a different general discrete distribution.</strong> For example, the distribution of orange, blue and green marbles with weights: p(orange) = 251/1000, p(blue) = 479/1000 and p(green) = 270/1000. We cannot use the first technique because there is no easy way to simplify these numbers. The second technique would require us to create 1000 boxes, so it also seems pretty bad. The weakness of our second technique is that the setup time depends on the weights, so the messier the numbers are the longer (and more space) it takes. This is not ideal. <br>
<br>
<strong>Now we can talk about a simple algorithm which solves our problem.</strong> The plan is to partition the interval [0,1] into n different parts based on the probabilities of each event. In our above example we could partition the interval into three sections with sizes orange = 0.251, blue = 0.479 and green = 0.27. Below is an O(n) algorithm to do this.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">weightedRandom</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draw from a general discrete distribution.</span>
<span class="sd">    :param weights: A dictionary of weights which sum to one.</span>
<span class="sd">    :return: A random sample from it the distribution defined by the weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#generate a uniform random number from 0 - 1</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> 

    <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">weights</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="n">remainder</span> <span class="o">-=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">remainder</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">color</span>

<span class="n">weights</span> <span class="o">=</span> <span class="p">{</span><span class="mf">3.0</span><span class="o">/</span><span class="mf">6.0</span> <span class="p">:</span> <span class="s2">&quot;orange&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">6.0</span> <span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">/</span><span class="mf">6.0</span> <span class="p">:</span> <span class="s2">&quot;green&quot;</span><span class="p">}</span>

<span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;orange&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">600000</span><span class="p">):</span>
    <span class="n">counts</span><span class="p">[</span><span class="n">weightedRandom</span><span class="p">(</span><span class="n">weights</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span> <span class="n">counts</span>
</pre></div>


<p><br>
<strong>So can we do better?</strong> The answer is sort of. It depends on what we want to do. It turns out if we want to sample from the same distribution multiple times, then we can. We will do just one preprocessing step (which will be the same time/space complexity for any set of n weights) and after that each sample will be O(1). So the more times we want to sample from the same distribution, the better the performance will be.<br>
<br>
<strong>How does this work?</strong>
I'm going to go over the preprocessing step in a later section but first I'm going to describe how we do the O(1) lookups. Consider a general discrete probability distribution with n weights. We are going to divide it up into n boxes such that each box will contain pieces of either one or two different different weights and the pieces of these weights will sum to 1/n. From our definition the sum of all the pieces of all the weights in the boxes is 1 (the size of the entire distribution).<br>
<br>
<strong>The description can be difficult.</strong> I think a picture can really help. In this example we have three colored balls with weights p(blue) = 1/6, p(orange) = 3/6, p(green) = 2/6:
<p align="center">
    <img src="/images/alias-method/alias_diag.png" width="56%" > 
</p>
<strong>Once we have this partitioning, our algorithm is very simple:</strong> <br>
First we pick one of the 3 boxes. Then we choose a uniform random number between 0 and 1. We see which side of our chosen box it falls on and we return that color marble.<br>
<br>
<strong>Now we need to find these partitions.</strong> First of you might be asking yourself, why can we always partition the distribution like this? To answer that we will first provide an algorithm to construct these partitions then prove it always works.<br>
<br>
<strong>The basic idea of this algorithm is about filling up these boxes.</strong> First a quick observation. If we look at all the weights in a normalized (the sum of all the weights is one) probability distribution at least one of them must be less than or equal to 1/n where n is the total number of weights. Why is this important? This means that we can always fit one of these weights into a box of size 1/n possibly with some left over space.<br>
<br>
<strong>Our partitioning algorithm is as follows:</strong><br>
1) Sort the weights from least to greatest.<br>
2) Choose the smallest weight and put it into a box. Then if there is any space left over, fill in the extra room with some of the largest weight.<br>
3) Repeat steps 1 and 2 until all of the boxes have been filled.<br>
Here's a visualization of the algorithm:
<p align="center">
    <img src="images/alias-method/alias_anim.gif" width="56%" > 
</p>
<strong>Now why can we always do this?</strong> Now that we have the algorithm we can use induction to give a formal proof. Our claim is a little more general than what we have been saying earlier but it will make the proof easier.<br>
<br>
<strong>Claim:</strong> Given a set of n non-zero real numbers (called weights) we can partition them into n boxes of size s/n (where s is the sum of all n weights) such that each box only contains pieces of at most 2 weights using our algorithm.<br>
<br>
<strong>For the base case:</strong> Clearly if we have just one weight we can just put it in a single box by itself.<br>
<br>
<strong>Now comes our inductive step:</strong> Suppose that we know our claim is true for n - 1 weights. Now we must show it is true for n weights.<br>
<br>
<strong>Let's do the first step of our algorithm:</strong> We put the smallest weight in a box of size s/n. We know that it must fit because if it did not our weights would sum to more than s. Now if there is any left over space we fill it with some of our largest weight (by similar logic to the previous sentence this is also always possible). Finally we are left with one filled box and n - 1 unfilled boxes. We know by the inductive hypothesis (our assumption) that we can split whatever is remaining into those n - 1 boxes. Therefore we are done.<br>
<br>
<strong>Now finally what is the running time of the preprocessing step?</strong> First we need to sort all the weights which is O(nlog n). Now we need to do n steps where we get rid of the smallest weight and restart. However the key here is that only the largest weight needs to considered for sorting because its the only value let in the partition that is changed besides the one removed. We can do this in log n time with a binary search (because we have already sorted our weights). Therefore the rest of the algorithm is also O(n log n) so the whole algorithm is O(n log n).<br>
<br>
<strong>Here is an implementation of our algorithm:</strong><br>
<br></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">bintrees</span> <span class="kn">import</span> <span class="n">AVLTree</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">partitionWeights</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The preprocessing step.</span>
<span class="sd">    :param weights: A dictionary of weights which sum to one.</span>
<span class="sd">    :return: A partition used to draw quickly from the distribution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.00001</span> <span class="c1"># for floating point precision issues</span>
    <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">numWeights</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="c1"># We use a AVLTree to make our pull/push operations O(log n)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">AVLTree</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">numWeights</span><span class="p">):</span>
        <span class="n">smallestValue</span><span class="p">,</span> <span class="n">smallestColor</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">pop_min</span><span class="p">()</span> <span class="c1"># O(log n)</span>
        <span class="n">overfill</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">numWeights</span> <span class="o">-</span> <span class="n">smallestValue</span>
        <span class="k">if</span> <span class="n">overfill</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
            <span class="n">largestValue</span><span class="p">,</span> <span class="n">largestColor</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">pop_max</span><span class="p">()</span> <span class="c1"># O(log n)</span>
            <span class="n">largestValue</span> <span class="o">-=</span> <span class="n">overfill</span>
            <span class="k">if</span> <span class="n">largestValue</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">largestValue</span><span class="p">,</span> <span class="n">largestColor</span><span class="p">)</span> <span class="c1"># O(log n)</span>
            <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">smallestValue</span><span class="p">,</span> <span class="n">smallestColor</span><span class="p">,</span> <span class="n">largestColor</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">smallestValue</span><span class="p">,</span> <span class="n">smallestColor</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">boxes</span>

<span class="k">def</span> <span class="nf">drawFromPartition</span><span class="p">(</span><span class="n">partition</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The draw step.</span>
<span class="sd">    :param partition: partition A partition of a distribution into boxes.</span>
<span class="sd">    :return: A sample from the distribution represented by the partition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numBoxes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numBoxes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">value</span><span class="p">,</span> <span class="n">color1</span><span class="p">,</span> <span class="n">color2</span> <span class="o">=</span> <span class="n">partition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">/</span> <span class="n">numBoxes</span> <span class="o">&lt;=</span> <span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">color1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">color2</span>

<span class="n">weights</span> <span class="o">=</span> <span class="p">{</span><span class="mf">3.0</span><span class="o">/</span><span class="mf">6.0</span> <span class="p">:</span> <span class="s2">&quot;orange&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">6.0</span> <span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">/</span><span class="mf">6.0</span> <span class="p">:</span> <span class="s2">&quot;green&quot;</span><span class="p">}</span>

<span class="n">partition</span> <span class="o">=</span> <span class="n">partitionWeights</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

<span class="n">counts</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;orange&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">600000</span><span class="p">):</span>
    <span class="n">counts</span><span class="p">[</span><span class="n">drawFromPartition</span><span class="p">(</span><span class="n">partition</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span> <span class="n">counts</span>
</pre></div>


<p><strong>One final note on runtime.</strong> If you run our example code you'll notice the "slow" function is almost twice as fast as the "fast" one. Have I been lying this whole time? No. This is because in our example we used a small number of weights. In a <a href="https://gist.github.com/Mr4k/eabaca318499bd54e5e18431efbc6622">separate speed test</a> I use 1000 weights and draw from the distributions 100000 times each. In this case the fast algorithm runs in 0.35 seconds on my computer while the slow algorithm takes about 15 seconds.</p>
 </div>
</div>
<footer>
    <a href="/">home</a>
</footer>
    </div>

    <!-- Google Analytics -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        
        ga('create', 'UA-157308007-1', 'auto');
        ga('set', 'anonymizeIp', true);
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics -->
</body>

</html>