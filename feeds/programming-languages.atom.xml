<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>peterstefek.me - programming languages</title><link href="/" rel="alternate"></link><link href="/feeds/programming-languages.atom.xml" rel="self"></link><id>/</id><updated>2020-12-14T00:00:00-08:00</updated><entry><title>Dynamically Deducing Data Dependencies</title><link href="/dependency-tracking.html" rel="alternate"></link><published>2020-12-14T00:00:00-08:00</published><updated>2020-12-14T00:00:00-08:00</updated><author><name>Peter Stefek</name></author><id>tag:None,2020-12-14:/dependency-tracking.html</id><summary type="html">&lt;p&gt;Also an amazing alliteration&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Background&lt;/strong&gt;&lt;br&gt;
A few weeks ago, I was talking to &lt;a href="https://jemma.dev/"&gt;Jemma Issroff&lt;/a&gt;, a fellow &lt;a href="https://www.recurse.com/"&gt;Recurser&lt;/a&gt;, about a toy programming language she was building. We ended up thinking about automatically memoizing pure functions based on their parameters. As we thought about this problem more and more, we decided it would be interesting to be able to tell which parameters of function were actually required to compute its result at runtime. The idea at the time was that we could cache just based on those parameters. It turned out that just figuring out how to compute those dependencies was an interesting question in itself.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem Statement&lt;/strong&gt;&lt;br&gt;
Let's say we have a function &lt;span class="math"&gt;\(f\)&lt;/span&gt; that takes arguments &lt;span class="math"&gt;\(x_1,...,x_n\)&lt;/span&gt; and outputs some result &lt;span class="math"&gt;\(res\)&lt;/span&gt;. We want to check at runtime which of those arguments are really necessary to compute &lt;span class="math"&gt;\(res\)&lt;/span&gt;. Let's take a very simple example:&lt;br&gt;
&lt;pre&gt;
let f = fn(x, y, z) {
  return y
}
&lt;/pre&gt;
Now if we call 
&lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(x%2C%20y%2C%20z)%20%7B%0A%20%20return%20y%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependency%20of%20it%27s%20arguments%20as%20a%20graph%0Adep_diagraph(f(1%2C%202%2C%203))%0A"&gt;&lt;span class="math"&gt;\(f(1,2,3)\)&lt;/span&gt;&lt;/a&gt;
, it's pretty clear that the result &lt;span class="math"&gt;\(2\)&lt;/span&gt; only depends on &lt;span class="math"&gt;\(2\)&lt;/span&gt;, the value of the second argument. Of course we could have figured that out at compile time (and in fact most compilers will yell at you to tell you &lt;span class="math"&gt;\(x\)&lt;/span&gt; and &lt;span class="math"&gt;\(z\)&lt;/span&gt; are unused).
But now let's take a slightly more interesting case:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let f = fn(x, y, z) {&lt;/span&gt;
&lt;span class="err"&gt;  if (x &amp;gt; 0) {&lt;/span&gt;
&lt;span class="err"&gt;    return y&lt;/span&gt;
&lt;span class="err"&gt;  } else {&lt;/span&gt;
&lt;span class="err"&gt;    return z&lt;/span&gt;
&lt;span class="err"&gt;  }&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Unlike the first example, clearly all the variables are used here. However, if we evaluate
 &lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(x%2C%20y%2C%20z)%20%7B%0A%20%20if%20(x%20%3E%200)%20%7B%0A%20%20%20%20return%20y%0A%20%20%7D%20else%20%7B%0A%20%20%20%20return%20z%0A%20%20%7D%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(1%2C2%2C3)%0Adep_diagraph(f(1%2C%202%2C%203))%0A"&gt;&lt;span class="math"&gt;\(f(1,2,3)\)&lt;/span&gt;&lt;/a&gt;
  the output &lt;span class="math"&gt;\(2\)&lt;/span&gt; only depends on the values of &lt;span class="math"&gt;\(x\)&lt;/span&gt; and &lt;span class="math"&gt;\(y\)&lt;/span&gt;.   &lt;/p&gt;
&lt;p&gt;Let's stop here for a second and unpack that statement a little. Why am I saying the return value of &lt;span class="math"&gt;\(f(1,2,3)\)&lt;/span&gt; depends on both &lt;span class="math"&gt;\(x\)&lt;/span&gt; and &lt;span class="math"&gt;\(y\)&lt;/span&gt; even though the return value is exactly equal to the just value of &lt;span class="math"&gt;\(y\)&lt;/span&gt;?  &lt;/p&gt;
&lt;p&gt;The answer is because if the value of x were to change in a certain way (for example from &lt;span class="math"&gt;\(1\)&lt;/span&gt; to &lt;span class="math"&gt;\(-1\)&lt;/span&gt;), our return value would change.   &lt;/p&gt;
&lt;p&gt;On the other hand, the return value of 
&lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(x%2C%20y%2C%20z)%20%7B%0A%20%20if%20(x%20%3E%200)%20%7B%0A%20%20%20%20return%20y%0A%20%20%7D%20else%20%7B%0A%20%20%20%20return%20z%0A%20%20%7D%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(1%2C2%2C3)%0Adep_diagraph(f(-1%2C%202%2C%203))%0A"&gt;&lt;span class="math"&gt;\(f(-1,2,3)\)&lt;/span&gt;&lt;/a&gt;
 depends on &lt;span class="math"&gt;\(x\)&lt;/span&gt; and &lt;span class="math"&gt;\(z\)&lt;/span&gt;.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition of Dependency&lt;/strong&gt;&lt;br&gt;
So far, we've been talking about what dependence means informally. For all the &lt;a href="https://www.google.com/search?q=mathematicians"&gt;sticklers out there&lt;/a&gt;, I'm going to give a more concrete definition. We can say that expression &lt;span class="math"&gt;\(a\)&lt;/span&gt; depends on expression &lt;span class="math"&gt;\(b\)&lt;/span&gt; iff in order to compute the value of &lt;span class="math"&gt;\(a\)&lt;/span&gt; the value of &lt;span class="math"&gt;\(b\)&lt;/span&gt; must first be computed.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rules of Dependency Propagation&lt;/strong&gt;&lt;br&gt;
Now that we have an intuitive understanding of how to determine which dependencies a function needs, let's try to make this intuition into a concrete algorithm.  &lt;/p&gt;
&lt;p&gt;First we're going to quickly introduce one more operator &lt;span class="math"&gt;\(+\)&lt;/span&gt;.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let f = fn(x,y) {&lt;/span&gt;
&lt;span class="err"&gt;  return x + y&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The dependencies of any call to this function, for example &lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(x%2C%20y)%20%7B%0A%20%20return%20x%20%2B%20y%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(1%2C2%2C3)%0Adep_diagraph(f(1%2C%202))%0A"&gt;&lt;span class="math"&gt;\(f(1,2)\)&lt;/span&gt;&lt;/a&gt;, are simply x and y.
But now let's look at a more complicated example:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;Let f = fn(x, y, z) {&lt;/span&gt;
&lt;span class="err"&gt;  let s = z + y&lt;/span&gt;
&lt;span class="err"&gt;  if (s &amp;lt; 0) {&lt;/span&gt;
&lt;span class="err"&gt;    return x&lt;/span&gt;
&lt;span class="err"&gt;  } else {&lt;/span&gt;
&lt;span class="err"&gt;    return s&lt;/span&gt;
&lt;span class="err"&gt;  }&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This example isn't too much more complicated than any of the previous ones. A quick look will tell us 
&lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(x%2C%20y%2C%20z)%20%7B%0A%20%20let%20s%20%3D%20z%20%2B%20y%0A%20%20if%20(s%20%3C%200)%20%7B%0A%20%20%20%20return%20x%0A%20%20%7D%20else%20%7B%0A%20%20%20%20return%20s%0A%20%20%7D%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(1%2C2%2C3)%0Adep_diagraph(f(1%2C%202%2C%203))%0A"&gt;&lt;span class="math"&gt;\(f(1,2,3)\)&lt;/span&gt;&lt;/a&gt;
 will give a result of &lt;span class="math"&gt;\(5\)&lt;/span&gt; and will depend on &lt;span class="math"&gt;\(y\)&lt;/span&gt; and &lt;span class="math"&gt;\(z\)&lt;/span&gt;. It will also allow us to determine, 
 &lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(x%2C%20y%2C%20z)%20%7B%0A%20%20let%20s%20%3D%20z%20%2B%20y%0A%20%20if%20(s%20%3C%200)%20%7B%0A%20%20%20%20return%20x%0A%20%20%7D%20else%20%7B%0A%20%20%20%20return%20s%0A%20%20%7D%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(1%2C2%2C3)%0Adep_diagraph(f(1%2C%202%2C%20-3))%0A"&gt;&lt;span class="math"&gt;\(f(1, 2, -3)\)&lt;/span&gt;&lt;/a&gt;
  will give a result of &lt;span class="math"&gt;\(1\)&lt;/span&gt; and depend on &lt;span class="math"&gt;\(x\)&lt;/span&gt;, &lt;span class="math"&gt;\(y\)&lt;/span&gt; and &lt;span class="math"&gt;\(z\)&lt;/span&gt;. However, there is a more systematic way we can evaluate the dependencies (you're probably even using it in your head).   &lt;/p&gt;
&lt;p&gt;Let's create two rules, one for "+" and one for "if". Let's pretend x, y, z are generic expressions and deps(e) of an expression &lt;span class="math"&gt;\(e\)&lt;/span&gt; gives the set of all of its dependencies.&lt;br&gt;
Here are our two rules:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(let\,res = x + y;\)&lt;/span&gt; &lt;span class="math"&gt;\(deps(res) = deps(x) \cup deps(y)\)&lt;/span&gt; (where &lt;span class="math"&gt;\(\cup\)&lt;/span&gt; is the union of two sets)  &lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(let\,res = if\,(x)\,\{ y \}\,else\,\{ z \};\)&lt;/span&gt; if x is true then &lt;span class="math"&gt;\(deps(res) = deps(x) \cup deps(y)\)&lt;/span&gt; else &lt;span class="math"&gt;\(deps(res) = deps(x) \cup deps(z)\)&lt;/span&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Combining these two rules we can trace the dependencies of any function made up of only additions and if statements! While that's not really mind blowing, I found it kind of interesting.  &lt;/p&gt;
&lt;p&gt;Now if you are a battle hardened senior software engineer, you probably know that some of the most advanced programs powering cutting edge tech companies like Google and Facebook will occasionally use more operators than just "+" and "if".  &lt;/p&gt;
&lt;p&gt;So how do we handle other operations? Simple! Create more rules!    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arithmetic&lt;/strong&gt;&lt;br&gt;
Unlike in grade school, here arithmetic is simple. Almost all arithmetic operators follow the exact same rules as "+" (except multiplication).  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Short Circuit Operators&lt;/strong&gt;&lt;br&gt;
Okay now let's do multiplication. Imagine you have the following statement:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let f = fn(m, a, n, y, a, r, g, s) {&lt;/span&gt;
&lt;span class="err"&gt;  return m * a * n * y * a * r * g * s&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A call like &lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(m%2C%20a%2C%20n%2C%20y%2C%20a%2C%20r%2C%20g%2C%20s)%20%7B%0A%20%20return%20m%20*%20a%20*%20n%20*%20y%20*%20a%20*%20r%20*%20g%20*%20s%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(1%2C2%2C3%2C4%2C5%2C6%2C7%2C8)%0Adep_diagraph(f(1%2C%202%2C%203%2C%204%2C%205%2C%206%2C%207%2C%208))%0A"&gt;&lt;span class="math"&gt;\(f(1, 2, 3, 4, 5, 6, 7, 8)\)&lt;/span&gt;&lt;/a&gt; depends on every argument passed to f. However, what about this call &lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(m%2C%20a%2C%20n%2C%20y%2C%20a%2C%20r%2C%20g%2C%20s)%20%7B%0A%20%20return%20m%20*%20a%20*%20n%20*%20y%20*%20a%20*%20r%20*%20g%20*%20s%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(0%2C2%2C3%2C4%2C5%2C6%2C7%2C8)%0Adep_diagraph(f(0%2C%202%2C%203%2C%204%2C%205%2C%206%2C%207%2C%208))%0A"&gt;&lt;span class="math"&gt;\(f(0, 2, 3, 4, 5, 6, 7, 8)\)&lt;/span&gt;&lt;/a&gt;? Notice that the only variable which really affects the output of the product is &lt;span class="math"&gt;\(m\)&lt;/span&gt; with value 0. As long as the value of &lt;span class="math"&gt;\(m\)&lt;/span&gt; remains 0, the value of the result will be 0 no matter what value any other variable takes. This idea is conceptually similar to &lt;a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation"&gt;short circuit evaluation for boolean values&lt;/a&gt;.   &lt;/p&gt;
&lt;p&gt;Now you might ask what if there are multiple values that are all zero &lt;span class="math"&gt;\(f(0, 2, 3, 0, 5, 6, 7, 0)\)&lt;/span&gt;? Which one should we choose to depend on? &lt;br&gt;
There are a couple options here:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Choose the first available zero. This matches up with classic short circuit evaluation.&lt;/li&gt;
&lt;li&gt;Choose the zero with the fewest dependencies. Choosing this option is less efficient but will ensure that our deps function returns the smallest set of dependencies possible.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This optimization can also be applied to boolean functions such as &amp;amp;&amp;amp; and ||.   &lt;/p&gt;
&lt;p&gt;Short Circuit Rules (for the Classic Short Circuit Strategy):  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(let\,res = x_0\,*... *\,x_n;\)&lt;/span&gt; If no expression &lt;span class="math"&gt;\(x_i\)&lt;/span&gt; is zero, &lt;span class="math"&gt;\(deps(res) = \bigcup_{i=0} deps(x_i)\)&lt;/span&gt;.        Otherwise &lt;span class="math"&gt;\(let\,i =argmin_{i}\{x_i == 0\},\)&lt;/span&gt; &lt;span class="math"&gt;\(deps(res) = deps(x_i)\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(let\,res = x_0\,\&amp;amp;\&amp;amp;\,...\,\&amp;amp;\&amp;amp;\,x_n;\)&lt;/span&gt; If no expression &lt;span class="math"&gt;\(x_i\)&lt;/span&gt; is false, &lt;span class="math"&gt;\(deps(res) = \bigcup_{i=0}\,deps(x_i)\)&lt;/span&gt;. &lt;br&gt;
Otherwise &lt;span class="math"&gt;\(let\,i = argmin_{i}\{x_i == false\},\)&lt;/span&gt; &lt;span class="math"&gt;\(deps(res) = deps(x_i)\)&lt;/span&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(let\,res = x_0\,||... ||\,x_n;\)&lt;/span&gt; If no expression &lt;span class="math"&gt;\(x_i\)&lt;/span&gt; is true, &lt;span class="math"&gt;\(deps(res) = \bigcup_{i=0} deps(x_i)\)&lt;/span&gt;. Otherwise &lt;span class="math"&gt;\(let\,i = argmin_{i}\{x_i == true\},\)&lt;/span&gt; &lt;span class="math"&gt;\(deps(res) = deps(x_i)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Functions Calls&lt;/strong&gt;&lt;br&gt;
Here's a slightly trickier case:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let g = fn(x, y, z) {&lt;/span&gt;
&lt;span class="err"&gt;  if (x &amp;gt; 0) {&lt;/span&gt;
&lt;span class="err"&gt;    return y&lt;/span&gt;
&lt;span class="err"&gt;  } else {&lt;/span&gt;
&lt;span class="err"&gt;    return z&lt;/span&gt;
&lt;span class="err"&gt;  }&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;let f = fn(x, y, z) {&lt;/span&gt;
&lt;span class="err"&gt; return g(z,x,y)&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The above example represents a function call within a function call. In order to define this rule we need a few quick definitions:&lt;/p&gt;
&lt;p&gt;Let's define a function called &lt;span class="math"&gt;\(argdeps(f, a_0, a_1,...,a_n)\)&lt;/span&gt;. &lt;span class="math"&gt;\(argdeps\)&lt;/span&gt; takes a function &lt;span class="math"&gt;\(f\)&lt;/span&gt; and its arguments &lt;span class="math"&gt;\(a_0,...,a_n\)&lt;/span&gt; and returns indices of the arguments which are needed to compute the corresponding value of &lt;span class="math"&gt;\(f\)&lt;/span&gt;. Under the hood, this function is computed in the exact same way that we have been computing deps.&lt;/p&gt;
&lt;p&gt;Let's define f to be a function with n arguments, and x_0,...,x_n to be n expressions. Now we can make our rule:&lt;br&gt;
&lt;span class="math"&gt;\(let\,res = f(x_0,...,x_n);\)&lt;/span&gt;  &lt;span class="math"&gt;\(deps(f) = U_{i = argdeps(f,\,x_0,...,\,x_n)} deps(x_i)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lists&lt;/strong&gt;&lt;br&gt;
Now that we're feeling warmed up we can tackle one of the more complex rules sets.  &lt;/p&gt;
&lt;p&gt;Let's take a quick look at a function involving lists.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let f = fn(a) {&lt;/span&gt;
&lt;span class="err"&gt;  return a[0] + a[2]&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now fellow travellers, we have come to a fork in the road. To one side, lies the simple path on which we treat the entire list &lt;span class="math"&gt;\(a\)&lt;/span&gt; as a single unit. We would then say that the output of &lt;span class="math"&gt;\(f\)&lt;/span&gt; merely depends on a. To the other side lies the difficult path, to treat each element of &lt;span class="math"&gt;\(a\)&lt;/span&gt; as its own unit. &lt;/p&gt;
&lt;p&gt;Many would say, we can choose the best route to take based on tradeoffs and product requirements. Normally, I would agree that taking the simple path is a totally reasonable option. However on this particular journey, I believe we don't really have a choice, we have a responsibility.&lt;/p&gt;
&lt;p&gt;Let's look back at our example from above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let f = fn(a) {&lt;/span&gt;
&lt;span class="err"&gt;  return a[0] + a[2]&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The dependencies of this function are &lt;span class="math"&gt;\(a[0]\)&lt;/span&gt; and &lt;span class="math"&gt;\(a[2]\)&lt;/span&gt;. This new notation is very simple but important, especially when talking about multi dimensional arrays. One subtle note is that this notation allows us to specify different levels of granularity. &lt;span class="math"&gt;\(a[0]\)&lt;/span&gt; for example, could be a single element or an entire array. I have also not actually defined what the set &lt;span class="math"&gt;\(deps(a[0])\)&lt;/span&gt; is yet. Before we actually get there, it will be useful to look at a few more examples.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let f = fn(a) {&lt;/span&gt;
&lt;span class="err"&gt;  return a&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This example is incredibly simple but important to look at. Let's look at &lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(a)%20%7B%0A%20%20return%20a%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(%5B1%2C2%2C3%5D)%0Adep_diagraph(f(%5B1%2C2%2C3%5D))%0A"&gt;&lt;span class="math"&gt;\(f([1,2,3])\)&lt;/span&gt;&lt;/a&gt;. So it might seem like &lt;span class="math"&gt;\(f([1,2,3])\)&lt;/span&gt; just depends on the expressions at &lt;span class="math"&gt;\(a[0], a[1], a[2]\)&lt;/span&gt;, but is that really correct?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Recomputablity Test&lt;/strong&gt;&lt;br&gt;
Here's a way to test our intuition:&lt;/p&gt;
&lt;p&gt;Say we call a function &lt;span class="math"&gt;\(f\)&lt;/span&gt; once with args &lt;span class="math"&gt;\(x_0,...,x_n\)&lt;/span&gt; giving us the resulting value &lt;span class="math"&gt;\(r_0\)&lt;/span&gt; and the resulting set of dependencies &lt;span class="math"&gt;\(D_0\)&lt;/span&gt;. Then we call it again with arguments &lt;span class="math"&gt;\(y_0,...y_n\)&lt;/span&gt; and get the result &lt;span class="math"&gt;\(r_1\)&lt;/span&gt;. If all of the values of the dependencies given by &lt;span class="math"&gt;\(D_0\)&lt;/span&gt; are the same between the two calls, the results &lt;span class="math"&gt;\(r_0\)&lt;/span&gt; and &lt;span class="math"&gt;\(r_1\)&lt;/span&gt; should be the same. (Note this test only tells us if a set of dependencies is not valid, not that it's valid)&lt;/p&gt;
&lt;p&gt;Let's try using this test. &lt;span class="math"&gt;\(f([1,2,3])\)&lt;/span&gt; gives is the resulting array &lt;span class="math"&gt;\([1,2,3]\)&lt;/span&gt; and prospective dependency set &lt;span class="math"&gt;\(D_0\)&lt;/span&gt; = &lt;span class="math"&gt;\(a[0], a[1], a[2]\)&lt;/span&gt; with corresponding values &lt;span class="math"&gt;\(1,2,3\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now what if we call &lt;span class="math"&gt;\(f([1,2,3,4])\)&lt;/span&gt;? All of the values corresponding to &lt;span class="math"&gt;\(D_0\)&lt;/span&gt; remain unchanged so the value of &lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(a)%20%7B%0A%20%20return%20a%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(%5B1%2C2%2C3%2C4%5D)%0Adep_diagraph(f(%5B1%2C2%2C3%2C4%5D))%0A"&gt;&lt;span class="math"&gt;\(f([1,2,3,4])\)&lt;/span&gt;&lt;/a&gt; must be &lt;span class="math"&gt;\([1,2,3]\)&lt;/span&gt; right? It's easy to see that this is wrong, so &lt;span class="math"&gt;\(a[0], a[1], a[2]\)&lt;/span&gt; cannot be our only dependencies.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Length Dependencies&lt;/strong&gt;&lt;br&gt;
One way to fix our problem is to take an additional dependency on the length of a. We will use &lt;span class="math"&gt;\(lendeps(a)\)&lt;/span&gt; to denote the set of the expressions which the length of a depends on.&lt;/p&gt;
&lt;p&gt;So one rule which sums up what we've been saying is:&lt;br&gt;
&lt;span class="math"&gt;\(let\,res = a;\)&lt;/span&gt; (where a is a list) &lt;span class="math"&gt;\(deps(res) = \big(\bigcup_{i=0} deps(x_i)\big) \cup {lendeps(a)}\)&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;Since res is also an array we must also define its length dependencies with a second rule.&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(lendeps(res) = lendeps(a)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List Concatenation&lt;/strong&gt; &lt;br&gt;
Now let's talk about concatenation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let f = fn(a, b) {&lt;/span&gt;
&lt;span class="err"&gt;  return a + b&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If a and b are two lists, the resulting third list depends on both a, b, and their lengths. Let's define &lt;span class="math"&gt;\(res = a + b\)&lt;/span&gt;. The rules for computing deps(res) and lendeps(res) are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(deps(a+b) =\)&lt;/span&gt; &lt;span class="math"&gt;\(deps(a) \cup deps(b) \cup lendeps(a) \cup lendeps(b)\)&lt;/span&gt;  &lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(lendeps(res) = lendeps(a) \cup lendeps(b)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But we are not actually quite done yet. Check out the function below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;let f = fn(a, b) {&lt;/span&gt;
&lt;span class="err"&gt;  let c = b + a&lt;/span&gt;
&lt;span class="err"&gt;  return c[3]&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This function returns the 4th element of the concatenated list &lt;span class="math"&gt;\(a + b\)&lt;/span&gt;. So
 &lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(a%2C%20b)%20%7B%0A%20%20let%20c%20%3D%20b%20%2B%20a%0A%20%20return%20c%5B3%5D%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(%5B1%2C2%5D%2C%20%5B3%2C4%2C5%5D)%0Adep_diagraph(f(%5B1%2C2%5D%2C%5B3%2C4%2C5%5D))%0A"&gt;&lt;span class="math"&gt;\(f([1,2], [3,4,5])\)&lt;/span&gt;&lt;/a&gt;
would return 1 and 
&lt;a href="https://mr4k.github.io/konsole/?program=let%20f%20%3D%20fn(a%2C%20b)%20%7B%0A%20%20let%20c%20%3D%20b%20%2B%20a%0A%20%20return%20c%5B3%5D%0A%7D%0A%2F%2F%20this%20is%20a%20special%20builtin%20which%20renders%20the%20dependencies%20of%20its%20argument%20as%20a%20graph%0A%2F%2F%20to%20just%20get%20the%20normal%20output%20of%20f%20use%20the%20following%20instead%0A%2F%2F%20f(%5B1%2C2%5D%2C%20%5B3%2C4%2C5%2C6%5D)%0Adep_diagraph(f(%5B1%2C2%5D%2C%5B3%2C4%2C5%2C6%5D))%0A"&gt;&lt;span class="math"&gt;\(f([1,2],[3,4,5,6])\)&lt;/span&gt;&lt;/a&gt;
 would return &lt;span class="math"&gt;\(6\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Right now let's focus on the case of &lt;span class="math"&gt;\(f([1,2],[3,4,5,6])\)&lt;/span&gt;. The result depends on the 4th element of &lt;span class="math"&gt;\(c\)&lt;/span&gt; which is the 4th element of &lt;span class="math"&gt;\(a\)&lt;/span&gt;. Luckily the dependency set is simple here. It's just the 4th element of a. &lt;/p&gt;
&lt;p&gt;However if we look at the next case &lt;span class="math"&gt;\(f([1,2], [3,4,5])\)&lt;/span&gt;, the dependencies are a little more complicated. The result of this function does not just depend on a[0]. Can you see why? &lt;/p&gt;
&lt;p align="center"&gt;
    &lt;img src="/images/dependency-tracking/array-concat.png" width="65%" &gt; 
&lt;/p&gt;

&lt;p&gt;What happens if we increase the size of b, for example by calling &lt;span class="math"&gt;\(f([1,2], [3,4,5,6])\)&lt;/span&gt;? The answer is definitely no longer 1 so using the Recomputablity Test from before we can tell that the dependencies of &lt;span class="math"&gt;\(f([1,2], [3,4,5])\)&lt;/span&gt; cannot just be &lt;span class="math"&gt;\(a[0]\)&lt;/span&gt;. You may already see where this is going, &lt;span class="math"&gt;\(f([1,2], [3,4,5])\)&lt;/span&gt; must depend on both &lt;span class="math"&gt;\(a[0]\)&lt;/span&gt; and &lt;span class="math"&gt;\(len(b)\)&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;Here we are again faced with a choice. We can either say that all elements in a list depend on their value and the length of the list or we can break it down more granularly. Granularity costs time and memory so it's a legitimate tradeoff. I choose to go down the more granular road (in the interest of keeping the dependency set smaller) but I will write out the rules for both versions:  &lt;/p&gt;
&lt;p&gt;Recall above we defined &lt;span class="math"&gt;\(res = a + b\)&lt;/span&gt; with two lists &lt;span class="math"&gt;\(a\)&lt;/span&gt; and &lt;span class="math"&gt;\(b\)&lt;/span&gt;, then made a rule to define deps(res) and lendeps(res). So here's a third rule which is recursively applied to all elements e of &lt;span class="math"&gt;\(res\)&lt;/span&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(non granular version, larger dependency set) let &lt;span class="math"&gt;\(x\)&lt;/span&gt; be the child of &lt;span class="math"&gt;\(a\)&lt;/span&gt; or &lt;span class="math"&gt;\(b\)&lt;/span&gt; which corresponds to &lt;span class="math"&gt;\(e\)&lt;/span&gt;, &lt;span class="math"&gt;\(deps(e) = deps(x) \cup lendeps(a)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(granular version) 
let &lt;span class="math"&gt;\(x\)&lt;/span&gt; be a child of &lt;span class="math"&gt;\(a\)&lt;/span&gt; which corresponds to &lt;span class="math"&gt;\(e\)&lt;/span&gt;, &lt;span class="math"&gt;\(deps(e) = deps(x)\)&lt;/span&gt;.&lt;br&gt;
On the other hand, let &lt;span class="math"&gt;\(x\)&lt;/span&gt; be a child of &lt;span class="math"&gt;\(b\)&lt;/span&gt; which corresponds to &lt;span class="math"&gt;\(e\)&lt;/span&gt;, &lt;span class="math"&gt;\(deps(e) = deps(x) \cup lendeps(a)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A quick note about the computation feasibility of this rule. This rule as is applied recursively to every element in a and b so it is very computational intensive when you have large multidimensional arrays. I'd recommend using some kind of lazy evaluation for this rule in practice to avoid having to compute it for every element when unnecessary. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Can I try this out?&lt;/strong&gt;&lt;br&gt;
You may have noticed that all the code in this article looked a little strange. That's because it is all written the &lt;a href="https://github.com/jemmaissroff/koko"&gt;custom programming language&lt;/a&gt; Jemma has been building. The language supports all of the dependency tracking operations I talked about above and you can &lt;a href="https://mr4k.github.io/konsole/"&gt;play around with it yourself&lt;/a&gt;! If you need inspiration, every linked function in this blog post is a working example.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Where would stuff like this every come up?&lt;/strong&gt;
So I guess it's kind of cool that we can granularly track data dependencies, but more importantly why would we every want to? The answer is I'm not totally sure! But here are some quick ideas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Priviledged Access to Data and Derived Computations. Give every piece of data a security level. In order to access the output of a computation involving the data your security clearance must be greater than or equal to the maximum security clearance of all the dependencies.&lt;/li&gt;
&lt;li&gt;JITs which compile at only statements which are used.&lt;/li&gt;
&lt;li&gt;Constructing minimal auto differentiation graphs.&lt;/li&gt;
&lt;li&gt;Determining trace purity at runtime.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks to Jemma Issroff and Robert Lord for providing feedback on this post.&lt;/p&gt;
&lt;p&gt;Have questions / comments / corrections?&lt;br&gt;
Get in touch: &lt;a href="mailto:pstefek.dev@gmail.com"&gt;pstefek.dev@gmail.com&lt;/a&gt;   &lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="programming languages"></category><category term="programming languages"></category></entry></feed>