<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>peterstefek.me - graphics</title><link href="/" rel="alternate"></link><link href="/feeds/graphics.atom.xml" rel="self"></link><id>/</id><updated>2019-10-18T00:00:00-07:00</updated><entry><title>A Note on Ray Marching with Heightfields</title><link href="/ray-marching-heightfields.html" rel="alternate"></link><published>2019-10-18T00:00:00-07:00</published><updated>2019-10-18T00:00:00-07:00</updated><author><name>Peter Stefek</name></author><id>tag:None,2019-10-18:/ray-marching-heightfields.html</id><summary type="html">&lt;p&gt;Short stepping to avoid collisions&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;span class="math"&gt;\(\newcommand{\norm}[1]{\lvert \lvert #1 \rvert \rvert}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Ray marching is a technique for testing ray intersections with a scene.
If you are new to ray marching, I highly recommend reading one of these &lt;a href="https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm"&gt;great&lt;/a&gt; &lt;a href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/"&gt;introductions&lt;/a&gt;
to the technique.
The central idea in raymarching is that the scene is represented by a distance field function &lt;span class="math"&gt;\(D(pos)\)&lt;/span&gt;
which gives the distance to the closest surface at each point. This distance field function for a scene is usually built by combining the distance fields of many primitives such as spheres, cubes and planes. Usually the distance field of each primitive can be analytically defined. A simple example of one of these primitives is a sphere at the origin
with radius r whose distance field function is defined as follows in glsl:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;distSphere&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;pos&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;float&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;r&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;{&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;mag&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pos&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;r&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
}&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On thing you might notice here is that if you are inside the sphere the distance field is negative. This is called a signed distance field. While we don't use the signed part in this article you can find more information about them &lt;a href="https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm"&gt;here&lt;/a&gt;. &lt;br&gt;&lt;br&gt;
People often tend to use heightfields as primitives in raymarching. A heightfield is
a function &lt;code&gt;h(vec2 pos)&lt;/code&gt; that takes a 2d coordinate and returns the height
at that point. They can be thought of as topographical maps. Heightfields are useful because they allow artists to easily define bumpy surfaces such as waves or terrain. 
Common analytic heightfields include simplex noise, and sin / cosine waves.
Typically people use a function like the one below for the heightfield's distance field function:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;distHeightfield&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;vec3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;pos&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;{&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pos&lt;/span&gt;.&lt;span class="nv"&gt;xz&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;pos&lt;/span&gt;.&lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
}&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;where &lt;code&gt;h(vec2 pos)&lt;/code&gt; is the heightfield function. However this function is really not a distance field. To see why we can look at the image below.&lt;br&gt;
&lt;img alt="A ray can overshoot the closest surface when using heightfield distance" src="images/ray-marching-heightfields/heightfield-problem.png"&gt;&lt;br&gt;
Let's say we are at point P and we shoot a ray to the right (represented by the red ray in the picture). If we use our &lt;code&gt;distHeightfield&lt;/code&gt; function we will think that the closest surface is &lt;span class="math"&gt;\(a\)&lt;/span&gt; away. However in the direction our red ray is going, the closest point is really &lt;span class="math"&gt;\(b\)&lt;/span&gt; away which is smaller than &lt;span class="math"&gt;\(a\)&lt;/span&gt;. So if we took a step of size &lt;span class="math"&gt;\(a\)&lt;/span&gt; along the red ray we would overshoot the heightfield. &lt;br/&gt;&lt;br/&gt;
One way to solve this problem is to use a smaller step size. In fact it turns out we can just 
down scale our step size by a constant multiple. So instead of taking a step of size &lt;code&gt;D(pos)&lt;/code&gt; as 
usual we could take a step of size &lt;code&gt;D(pos)*shrinkFactor&lt;/code&gt;. One way to find the shrink factor is to just try plugging in small constants 
until we get good results. In practice, there is absolutely nothing wrong with this approach. But if we want we can apply a more principled approach to finding a shrink factor.  &lt;br/&gt;&lt;br/&gt;
&lt;strong&gt;Obtaining a shrink factor&lt;/strong&gt;:&lt;br&gt;
Let's start by just trying to obtain a safe distance which gives us a lower bound on how far we can go in any direction without hitting anything. A really simple
way to do that is by creating a surface that will always be between our point P and the heightfield and finding the closest distance to that surface.&lt;br&gt;
A cone (more of a v shape in 2d) whose bottom starts on the heightfield directly under P is a good choice. Here is a picture:&lt;br&gt;
&lt;img alt="A safety cone" src="images/ray-marching-heightfields/safety-cone.png"&gt;&lt;br&gt;
Now we need is to chose a slope &lt;code&gt;c&lt;/code&gt; for the sides of the cone such that the it's edges will always lie between the heighfield and our point. If our heighfield function
is continuous and its derivative is bounded everywhere it is defined then &lt;code&gt;c&lt;/code&gt; could be the lowest upper bound on the absolute value of the derivative.  &lt;br/&gt;&lt;br/&gt;
Finally we have to find the closest distance from P to the edges of the cone. This distance will be our conservative bound.  &lt;br/&gt;&lt;br/&gt;
Note while the math below is in 2d, the 3d case is basically identical:&lt;br&gt;
&lt;img alt="A picture to set up our derivation" src="images/ray-marching-heightfields/derivation-diagram.png"&gt;&lt;br&gt;
Let &lt;span class="math"&gt;\(O\)&lt;/span&gt; be the bottom of the cone and &lt;span class="math"&gt;\(N\)&lt;/span&gt; be the closest point on one of the edges of the cone to &lt;span class="math"&gt;\(P\)&lt;/span&gt;. For consistency we will choose the right edge although it doesn't matter.&lt;br&gt;
First define &lt;span class="math"&gt;\(\hat{C}\)&lt;/span&gt; as the normalized vector pointing from &lt;span class="math"&gt;\(O\)&lt;/span&gt; along the right edge of the cone.&lt;br&gt;
&lt;span class="math"&gt;\(\norm{\overrightarrow{ON}}\)&lt;/span&gt; is given by &lt;span class="math"&gt;\(\overrightarrow{OP}\cdot \hat{C}\)&lt;/span&gt;.&lt;br&gt;
Given that &lt;span class="math"&gt;\(\overrightarrow{OP} = (0, h(P))\)&lt;/span&gt; we can say, &lt;span class="math"&gt;\(\norm{\overrightarrow{ON}} = \frac{h(P)c}{\sqrt{1+c^2}}\)&lt;/span&gt;.&lt;br&gt;
Finally using the pythagorean theorem we can find &lt;span class="math"&gt;\(\norm{\overrightarrow{PN}} = \norm{\overrightarrow{OP} } - \norm{\overrightarrow{ON}}\)&lt;/span&gt; which is &lt;span class="math"&gt;\(\frac{1}{\sqrt{c^2+1}}h(p)\)&lt;/span&gt;. &lt;br&gt; &lt;span class="math"&gt;\(\norm{\overrightarrow{PN}}\)&lt;/span&gt; is our conservative lower bound. This also means we can use &lt;span class="math"&gt;\(\frac{1}{\sqrt{c^2+1}}\)&lt;/span&gt; as our shrink factor.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="graphics"></category><category term="raymarching"></category><category term="graphics"></category></entry></feed>