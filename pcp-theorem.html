<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>The PCP Theorem and the Hardness of Approximation</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="peterstefek.me Atom Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">peterstefek.me </a></h1>
                <nav><ul>
                    <li class="active"><a href="/category/algorithms.html">algorithms</a></li>
                    <li><a href="/category/graphics.html">graphics</a></li>
                    <li><a href="/category/probability.html">probability</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/pcp-theorem.html" rel="bookmark"
           title="Permalink to The PCP Theorem and the Hardness of Approximation">The PCP Theorem and the Hardness of Approximation</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2018-04-29T02:50:00-07:00">
                Published: Sun 29 April 2018
        </abbr>
		<br />
        <abbr class="modified" title="2019-08-14T09:30:00-07:00">
                Updated: Wed 14 August 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/peter-stefek.html">Peter Stefek</a>
        </address>
<p>In <a href="/category/algorithms.html">algorithms</a>.</p>
<p>tags: <a href="/tag/algorithms.html">algorithms</a> <a href="/tag/theory.html">theory</a> </p>
</footer><!-- /.post-info -->      <p><strong>Preamble</strong><br>
This post uses a lot of computational complexity terms and is fairly dense. I've included some defintions of frequently used terminology below. <br><br></p>
<ul>
<li>
<p>Complexity classes: A complexity class is a set of problems that can all be solved with an upper bounded constraint on a resource based on input size. In this article our constrained resource will usually be algorithmic runtime. <br><br></p>
</li>
<li>
<p>P and NP: P is the complexity class made up of problems that can be solved in polynomial time by a deterministic Turing machine. NP is the class of problems that can be solved in polynomial time by a non-deterministic Turing machine. A major problem in computer science is proving whether or not P=NP. In this post most of the work will be built on the assumption that P <span class="math">\(\neq\)</span> NP. If this assumption is false many of our theorems will be irrelevant. <br><br></p>
</li>
<li>
<p>Reductions: A reduction is an algorithm which transforms one problem into another. In this post we will mostly focus on reductions that can be done in polynomial time. A problem is NP-hard if any problem in NP can be reduced to it in polynomial time. Showing that a problem is NP-hard by reducing another NP-hard (or NP Complete) problem to it is a common proof strategy. Notice that showing that a problem is NP-hard does not mean that it is in NP (it could be harder)<br><br></p>
</li>
<li>
<p>NP-Complete: An NP-Complete problem is an NP-hard problem that is also in NP. <br><br></p>
</li>
<li>
<p>Strings and Languages: We can also talk about complexity classes (such as P and NP) in terms of languages which accept certain strings. A language is a collection of strings. For example one language is the language of all strings which contain an odd number of 0s. A more complex example of a language is the set of all strings which represent bipartite graphs (the way we represent graphs as strings is not usually important). Determining whether or not a string is in a given language is now the problem we have to solve. For example we can say that a language <span class="math">\(L\)</span> is in P if and only if for any string <span class="math">\(x\)</span> we can determine if <span class="math">\(x \in L\)</span> in polynomial time. <br><br></p>
</li>
</ul>
<p><strong>Probabilistic Checkable Proofs</strong> <br></p>
<p>Probabilistic checkable proofs are a type of complexity class. The basic idea is this, consider a theorem and a lazy student. The lazy student has to decide whether or not the proof is true but does not want to read all of it. In fact the student only wants to read q bits of the proof before going back to sleep. The student also has r quarters (for laundry) next to them on their desk which they can flip (one time per coin) to help make random decisions. Given these r quarters and q bits the student must decide quickly whether or not the proof is true with a high probability. <br><br></p>
<p align="center">
    <img src="/images/pcp-theorem/pcp_verifier.png" width="80%" > 
</p>

<p>More formally we will first define a probabilistic polynomial time verifier for a language L as follows: <br>
The verifier takes a string x and a proof (that x is in L) as input. The verifier gets to read <span class="math">\(q\)</span> bits of the proof and <span class="math">\(r\)</span> random bits (drawn from a uniform distribution). Using these two pieces of information the verifier must then decide in polynomial time whether or not x is in L. <br><br>
Define the complexity class PCP(r, q) as follows: <br>
Let L be a language and v be a probabilistic polynomial time verifier which can read q bits of a proof and has access to string of r random bits drawn from a uniform distribution. Then language L is in <span class="math">\(PCP(r,q)\)</span> if and only if <br>
Completeness: For every <span class="math">\(x \in L\)</span>, there exists a proof that <span class="math">\(x \in L\)</span> which v accepts with probability 1 <br>
Soundness: For every <span class="math">\(x \not\in L\)</span>, v accepts all proofs that <span class="math">\(x \in L\)</span> with probability at most <span class="math">\(\frac{1}{2}\)</span> <br><br>
What does this mean? To gain a basic understanding lets look at some simple edge cases:<br><br></p>
<ul>
<li>
<p><span class="math">\(PCP(0,0) = P\)</span> (Claim 1)<br><br>
Notice <span class="math">\(P \subseteq PCP(0,0)\)</span> Let L be any language in P. Since our verifier has polynomial arbitrary steps of computation we can verify that any <span class="math">\(x \in P\)</span> with probability 1 without a proof or any randomness by replicating the polynomial time solver for L. Also notice <span class="math">\(PCP(0,0) \subseteq P\)</span> because there is no randomness or proof to use. If we could accept any language <span class="math">\(L' \not\in P\)</span> then we would have a deterministic polynomial time algorithm which told us if any <span class="math">\(x\)</span> was in <span class="math">\(L'\)</span>. This algorithm creates a contradiction because by definition of <span class="math">\(L'\)</span> there is no polynomial time algorithm to determine if any arbitrary string <span class="math">\(x\)</span> is in <span class="math">\(L'\)</span>. <span class="math">\(\square\)</span> <br><br></p>
</li>
<li>
<p><span class="math">\(PCP(0, O(1)) = P\)</span> (Claim 2)<br><br>
To show <span class="math">\(P \subseteq PCP(0, O(1))\)</span> we can use claim 1 and notice that <span class="math">\(P \subseteq PCP(0, 0) \subseteq PCP(0, O(1))\)</span>. Now all we have to show is that <span class="math">\(PCP(0, O(1)) \subseteq P\)</span>. We will use a similar strategy to last time but with a few tweaks. Let's pretend there is a language <span class="math">\(L' \not\in P\)</span> but <span class="math">\(L' \in PCP(0,O(1))\)</span>. In this case we know there is a way to check deterministically in polynomial time whether any <span class="math">\(x \in L'\)</span> by only reading a constant number of bits of the proof. Let's call this constant c. One important fact is that c is the same for every <span class="math">\(x\)</span>. Therefore we can run our polynomial time algorithm on each of the <span class="math">\(2^c\)</span> possible bits of the proof in polynomial time (with respect to the size of <span class="math">\(x\)</span>). If one of these combinations of bits gets accepted then we know <span class="math">\(x \in L'\)</span> (completeness) otherwise we know <span class="math">\(x \not\in L'\)</span> (soundness). Therefore we have just built a polynomial time algorithm to check if <span class="math">\(x\)</span> is in <span class="math">\(L'\)</span>. This algorithm creates a contradiction because by definition <span class="math">\(L'\)</span> there is no polynomial time algorithm to determine if any arbitrary string <span class="math">\(x\)</span> is in <span class="math">\(L'\)</span>. <span class="math">\(\square\)</span> <br><br></p>
</li>
<li>
<p><span class="math">\(PCP(O(\mbox{log n}), 0) = P\)</span> (Claim 3) <br><br>
As with the claim 2, we can show  <span class="math">\(P \subseteq PCP(0, O(1)\)</span> by observing that, <span class="math">\(P \subseteq PCP(0,0) \subseteq PCP(O(\mbox{log n}), 0)\)</span>. To show <span class="math">\(PCP(O(\mbox{log n}),0) \subseteq P\)</span> we will have to again tweak our strategy from before. As before consider an <span class="math">\(L' \not\in P\)</span> but <span class="math">\(L' \in PCP(O(\mbox{log n},0)\)</span>. Unlike last time our verifier's algorithm is not deterministic. However we can make it deterministic by running our verifier's algorithm on every possible random string of r bits. We know that r is <span class="math">\(O(\mbox{log n})\)</span> so there are <span class="math">\(2^{r}\)</span> combinations which is at most <span class="math">\(2^{O(\mbox{log n})} = O(n)\)</span>. So we just have to run our polynomial verifier algorithm on a linear number of different random bit strings which gives us a deterministic polynomial time algorithm to check if any <span class="math">\(x \in L'\)</span>. <span class="math">\(\square\)</span> <br><br></p>
</li>
</ul>
<p>So after looking at all of these cases, what do we think <span class="math">\(PCP(O(log n), O(1))\)</span> equals?</p>
<p>PCP Theorem: <span class="math">\(PCP(O(log n), O(1)) = NP\)</span> <br><br></p>
<p>This means that for any decision problem in NP, we can construct a small probabilistic polynomial time verifier which can solve the decision problem up to soundness by at most looking at constant bits of an argument about what the answer is far faster than we could solve the problem deterministically.
Seems surprising, right? We will not prove this theorem in this post but we will use it to show some results about how hard it is to approximate certain NP-Complete problems.<br><br></p>
<p><strong>MAX-3SAT</strong><br>
3SAT is a famous NP-Complete Problem. It goes like this: <br/>
Take a set of m variables and n clauses. Each clause has exactly three literals (variables which may be negated) in it all of them are or'ed together. We then take the conjunction of all of the clauses together. This expression is said to be in 3 conjunctive normal form (3CNF). Here is an example of a 3CNF expression, <br><br>
<div style="text-align:center;"></p>
<div class="math">$$(x_1 \lor x_2 \lor x_3) \land (\bar x_4 \lor x_1 \lor x_3) \land (\bar x_3 \lor \bar x_2 \lor x_4)$$</div>
<p></div> <br>
 The classical 3SAT problem asks if all of the clauses can be simultaneously satisfied.  <br/>
However sometimes we can't satisfy all of the clauses. MAX-3SAT an optimization problem in which we are given an 3CNF expression and we try to find the maximum number of clauses which can all be satisfied together. <br/><br/>
Since MAX-3SAT is NP-Complete we know that we cannot solve it exactly in polynomial time unless P=NP. But what if we could get close? <br /><br />
We say that an problem has a polynomial time approximation scheme (PTAS) if for all <span class="math">\(\epsilon &gt; 0\)</span> we can approximate the problem in polynomial time within a factor of <span class="math">\(\epsilon\)</span> of the optimal solution. It is important to note however that the runtime of a PTAS must only be polynomial in terms of n (the size of the input) and could be different for different epsilons. For example <span class="math">\(O(n^\frac{1}{\epsilon})\)</span> is still polynomial in terms of n. Polynomial time approximation schemes are the only way forward for some NP-Hard problems such as Knapsack and Load Balancing. Sadly, MAX-3SAT has no PTAS. <br /><br /></p>
<p><strong>Theorem:</strong> <span class="math">\(NP \subseteq PCP(log(n), O(1))\)</span> (PCP Theorem) implies that MAX-3SAT is inapproximable in polynomial time within some <span class="math">\(\epsilon &gt; 0\)</span> unless P=NP. <br /><br />
<p>Assume we have a polynomial time approximation scheme for MAX-3SAT. We will show that using this PTAS for MAX-3SAT and a fixed <span class="math">\(\epsilon\)</span> we can solve <b>any</b> NP complete decision problem in polynomial time. Let <span class="math">\(L\)</span> be the language of strings which satisfy your favorite NP- Complete decision problem. Let <span class="math">\(x\)</span> be a string of any size n. We want to know if <span class="math">\(x\)</span> is in <span class="math">\(L\)</span>. Since <span class="math">\(L \in PCP(log(n), O(1))\)</span> there is an verifier which takes <span class="math">\(x\)</span>, log n bits of randomness and a proof that <span class="math">\(x \in L\)</span>. The verifier reads c (a constant) bits of the proof and then decides whether or not <span class="math">\(x\)</span> is in <span class="math">\(L\)</span>. The completeness property of the verifier says that if <span class="math">\(x \in L\)</span> then there is a proof that we can give the verifier so that it will always return true. The soundness property says that if <span class="math">\(x \not \in L\)</span> then for every proof the verifier will return true less than half of the time. <br> <br>
 For any random string of <span class="math">\(O(log(n))\)</span> bits r we can figure out in polynomial time which bits of the proof our verifier will check. Let <span class="math">\(Q_r\)</span> be a set of variables corresponding to the locations of each bit our verifier will check. Also define a set of 3CNF clauses <span class="math">\(C_r\)</span> with <span class="math">\(Q_r\)</span> as its variables. Together the clauses <span class="math">\(C_r\)</span> will mimic the output of our verifier (with random string r) when it reads the bits represented by the variables in <span class="math">\(Q_r\)</span>. It's important that the number of clauses in any <span class="math">\(C_r\)</span> does not depend on the size of our input.
<details>
    <summary>(details)</summary>
    <br>PCP says our verifier only needs to read a c bits of the proof no matter what the size of the input is. In the worst case we could write a CNF formula that maps every possible configuration of the c bits to true or false. In this case we have <span class="math">\(2^c\)</span> clauses with c variables per clause. It turns out that we can also translate every CNF instance into a 3CNF instance in polynomial time which means that we may end up with more clauses, but the the number of clauses will still only depend on c not n the size of the input. Therefore this construction is constant in time and space with respect to n. 
</details></p> <br>
Now define <span class="math">\(Q\)</span> to be the union of all sets <span class="math">\(Q_r\)</span> for every possible r and <span class="math">\(C\)</span> to be the union of <span class="math">\(C_r\)</span>. One important fact is that the size of <span class="math">\(Q\)</span> and <span class="math">\(C\)</span> is linear with respect to n. This is because the size of each <span class="math">\(Q_r\)</span> and <span class="math">\(C_r\)</span> is a constant and the total number of possible strings r = <span class="math">\(2^{O(log(n))} = O(n)\)</span>. So the size of <span class="math">\(Q,C\)</span> is at most <span class="math">\(O(n)\)</span>.<br><br></p>
<p>Finally create a 3CNF instance whose set of variables is <span class="math">\(Q\)</span>, and whose set of clauses is the conjunction of all the clauses in <span class="math">\(C\)</span>. Together all the variables in <span class="math">\(Q\)</span> represent a proof <span class="math">\(\pi\)</span> (or at least all the parts that our verifier could ever read) that <span class="math">\(x \in L\)</span>. Each set of clauses <span class="math">\(C_r\)</span> represents the output of the verifier with a certain random string r given access to our proof <span class="math">\(\pi\)</span>. Due to completeness, if <span class="math">\(x\)</span> is satisfiable then there is a proof <span class="math">\(\pi\)</span> such than all of the clauses will be satisfied. <details>
    <summary>(details)</summary>
    <br>Now this is not technically true since we may have broken our larger clauses in small 3CNF clauses. So for example if we broke one clause with 11 terms into 4 different 3CNF clauses then only one of those would have to be satisfied. In cases like this we count all these clauses as one (if one is satisfied then we are happy).<br><br>
</details> If the proof is incorrect then due to soundness, less than half of the clauses will be satisfied for every proof. If <span class="math">\(\epsilon\)</span> is small enough our PTAS have to satisfy more than half of the <span class="math">\(C_r\)</span>s if and only if our <span class="math">\(x\)</span> is in <span class="math">\(L\)</span>. Notice the same <span class="math">\(\epsilon\)</span> works no matter what <span class="math">\(x\)</span> is because the size of our construction did not depend on the n. Therefore, a PTAS for MAX-3SAT would give us a polynomial time algorithm to solve any NP Complete decision problem. <span class="math">\(\square\)</span></p> <br></p>
<p>In short what we just did was assume that there was a PTAS for MAX-3SAT. Then we used this PTAS to construct a polynomial time deterministic solver for any NP-Complete decision problem. Because our PTAS takes polynomial time we know that its existence would prove P = NP which in our case is a contradiction (we assume P <span class="math">\(\neq\)</span> NP). Part of what makes this proof so cool is that the reduction doesn't change depending on what NP Complete decision problem we use. For maximum confusion I recommend using 3SAT. <br><br></p>
<!--<br />
**MAXSNP and Immediate consequences of our theorem**
One interesting and immediate consequence of our above theorem can be observed by looking at the class of problems MAXSNP. MAXSNP are NP-Hard optimization problems with the property that if there is an approximation for one of the problems, it can be used to approximate any of the other problems in the class. Many problems such as Independent Set and MAXCUT are in MAXSNP. Coincidently MAX-3SAT is also in MAXSNP. This is really interesting because from our above proof we have inadvertently just shown that everything else in MAXSNP has no PTAS.
<br><br>!-->

<p><strong>The Hardness of Approximating Max Clique</strong> <br/>
A clique is a set of vertices in a graph which are all connected to each other. The size of a clique is the number of vertices it contains. Here's an example of a clique of size 4 <br/>
<p align="center">
    <img src="/images/pcp-theorem/clique_4.png" width="30%" > 
</p>
Given a graph G the Max Clique problem is to find the largest clique in G. Max Clique is NP-Complete, which means that it cannot be solved exactly in polynomial time unless P=NP. But can we get close to the optimal solution? In a surprising twist just like MAX-3SAT, Max Clique does not have a PTAS. <br/><br></p>
<p><strong>Theorem:</strong> Max Clique is inapproximable in polynomial time within some <span class="math">\(\epsilon &gt; 0\)</span> unless P=NP. <br><br>
To prove this statement we will show that Max Clique on a certain graph corresponds to MAX-3SAT so closely that if we had a PTAS for Max Clique we would have a PTAS for MAX-3SAT. Heres how we construct this graph. Given a set of <span class="math">\(m\)</span> clauses in 3CNF form, we can construct a graph G as follows. For each clause <span class="math">\(c_k\)</span> add 3 vertices each one representing a literal in that clause. For every vertex v connect v to every other vertex which is not part of the same clause and that does not represent a negation of the literal v represents. Here is an example of this construction with two clauses, <br>
<p align="center">
    <img src="/images/pcp-theorem/sat-to-mclique.png" width="65%" > 
</p>
Let's say we find a clique of size k in this graph.  Consider what would happen if we set the variables corresponding to each vertex in our clique to true (or false if they are negations) and all the other variables to false (or true if they are negations). We can do this with no conflicts because by our construction no two vertices in the clique are negations of each other. Also by construction each vertex is in a different clause so at least k different clauses are satisfied. <br>
Now consider <span class="math">\(x\)</span> an instance of MAX-3SAT. We know since MAX-3SAT has no PTAS <span class="math">\(\exists \delta &gt; 0\)</span> such that we cannot approximate MAX-3SAT within <span class="math">\(\delta\)</span>. Now choose let our PTAS be an <span class="math">\(1+\epsilon\)</span> approximation where <span class="math">\(\epsilon &lt; \delta\)</span>. We can turn our <span class="math">\(x\)</span> into a graph following our construction above. Notice that a <span class="math">\(1 - \epsilon\)</span> approximation of max clique gives us a <span class="math">\(1 - \epsilon\)</span> approximation for MAX-3SAT. This is a problem because we have just created a PTAS for MAX-3SAT.<span class="math">\(\square\)</span> <br> <br></p>
<p>Okay, we can't do construct a PTAS, so we can't get as close as we want. What about approximating MAX Clique within some constant factor? Plenty of NP-Complete problems have a constant factor approximation including MAX-3SAT. As you may have guessed we won't be so lucky with Max Clique. <br><br></p>
<p><strong>Theorem:</strong> Max Clique has no constant factor approximation unless P = NP. <br><br></p>
<p>Before we prove this theorem we have to build up some machinery on graphs. We will do this by defining the strong graph product. <br><br>
<strong>Definition</strong> The (strong) graph product on graphs <span class="math">\(G = G_1 \bigotimes G_2\)</span> is defined as follows: <br>
<span class="math">\(V_G = V_{G_1} \times V_{G_2}\)</span> (where <span class="math">\(\times\)</span> is the Cartesian product) <br>
<span class="math">\(E_G = \\{(u_1,v_1), (u_2,v_2)\\}\)</span> such that <span class="math">\((u_1, u_2) \in E_{G_1}\)</span> or <span class="math">\(u_1 = u_2, (v_1, v_2) \in E_{G_2}\)</span> or <span class="math">\(v_1 = v_2\)</span> <br>
Here's an example,
<p align="center">
    <img src="/images/pcp-theorem/strong-graph-product.png" width="80%" > 
</p><br>
While this definition may seem daunting one can visualize it by imagining that we are putting a copy of <span class="math">\(G_1\)</span> at every vertex of <span class="math">\(G_2\)</span> then connecting the edges according to our edge rules. 
Look at the max clique size <span class="math">\(\omega(G)\)</span> for each graph in the drawing above: </p>
<div class="math">$$\omega(G_1) = 2, \omega(G_2) = 2, \omega(G_1 \bigotimes G_2) = 4$$</div>
<p> <br><br>
What can we make of this? It turns out that an important fact about graph products is,
<p style="display:inline;">
    <div style="text-align:center;"><span class="math">\(\omega(G_1 \bigotimes G_2) = \omega(G_1)\omega(G_2)\)</span></div>
<details style="display:inline;">
    <summary>(details)</summary>
    <br>Take the two largest cliques <span class="math">\(C_1 \in G_1, C_2 \in G_2\)</span>. When we take the graph product <span class="math">\(G'\)</span> we place a copy of <span class="math">\(G_1\)</span> (including <span class="math">\(C_1\)</span>) at each vertex in <span class="math">\(G_2\)</span>. Now consider subgraph <span class="math">\(G'\)</span> made of the copies of <span class="math">\(C_1\)</span> placed at vertices that make up <span class="math">\(C_2\)</span>. Consider any edge in G' between two vertices <span class="math">\(\\{(u_1,v_1), (u_2,v_2)\\}\)</span>. Since <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are cliques, <span class="math">\((u_1, u_2) \in E_{G_1}\)</span> or <span class="math">\(u_1 = u_2\)</span>. The same goes for <span class="math">\(v_1\)</span> and <span class="math">\(v_2\)</span>. So our subgraph is entirely connected. The size of this subgraph is <span class="math">\(\lvert C_1 \rvert \lvert C_2 \rvert\)</span>. Since this subgraph is a clique the max clique has size at least <span class="math">\(\lvert C_1 \rvert \lvert C_2 \rvert = \omega(G_1)\omega(G_2)\)</span>.<br><br> Finally how do we know there is not a larger clique? Well let's reverse our logic. Suppose there is a clique <span class="math">\(C' \in G'\)</span> which is larger than <span class="math">\(\omega(G_1)\omega(G_2)\)</span>. Then we can decompose this clique into one clique in <span class="math">\(G_1\)</span> and one in <span class="math">\(G_2\)</span>. We must be able to do this decomposition because each of if one of the set of vertices that is part of this clique was not a clique itself then we would have a contradiction. 
    <br><br>
</details>.</p><br></p>
<p>Now we return to showing that Max Clique has no constant approximation. Assume we have an <span class="math">\(\alpha\)</span>-approximation for Max Clique. Now we know there <span class="math">\(\exists \beta &gt; 0\)</span> such that Max Clique cannot be approximated within any factor larger than <span class="math">\(\beta\)</span> in polynomial time (Max Clique has not PTAS). Choose a <span class="math">\(k\)</span> such that <span class="math">\(\beta^k &lt; \alpha\)</span>. Take in a graph G. Compute <span class="math">\(G^k\)</span> by taking the repeated graph product. Now use our alpha approximation algorithm on <span class="math">\(G^k\)</span>. Remember our fact from earlier, <br>
<div style="text-align:center;"></p>
<div class="math">$$\omega(G^k) = \omega(G)^k$$</div>
<p></div>
Let <span class="math">\(C'\)</span> denote the clique we found. Then we can say: <br>
<div style="text-align:center;"></p>
<div class="math">$$ \lvert C' \rvert = \alpha \omega(G^k) $$</div>
<p></div> 
This implies that there is a clique <span class="math">\(C\)</span> in our original graph such that:
<div style="text-align:center;"></p>
<div class="math">$$ \lvert C \rvert = \sqrt[k]{(\lvert C' \rvert)} = \sqrt[k]{(\alpha w(G^k))} = \sqrt[k]{(\alpha)}w(G)$$</div>
<p></div>
We know by our definition of k that:<br>
<div style="text-align:center;"></p>
<div class="math">$$ \sqrt[k]{(\alpha)}w(G) &gt; \beta w(G) $$</div>
<p></div> 
Therefore we have just created a polynomial approximation for Max Clique within <span class="math">\(\epsilon\)</span>. Unless P=NP this is a contradiction. <span class="math">\(\square\)</span> <br><br>
So it turns out that Max Clique is really bad. In fact the best results on the hardness of Max Clique indicate the the only approximation one can make is a clique of size one (i.e choosing a single vertex). <br> <br></p>
<p><strong>Getting better hardness guarantees</strong> <br>
So far, our results with the standard PCP Theorem have been quite cool. We have used a powerful tool to show that some NP-Complete Problems aren't just hard to solve exactly but are hard to approximate up to a certain point. One question is could we be more specific? It is simple to come up with a <span class="math">\(\frac{7}{8}\)</span>-approximation algorithm for MAX-3SAT but can we do better? After the PCP Theorem was introduced, researchers have become less interested in proving that there is no PTAS for certain problems and more interested in optimal inapproximability. <br>
<br> <strong>Definition</strong> An optimal inapproximability result for a problem says there is both an algorithm which is an <span class="math">\(\alpha\)</span> approximation that problem as well as a proof that the problem cannot be approximated within a factor of <span class="math">\(\alpha + \epsilon\)</span> for any <span class="math">\(\epsilon &gt; 0\)</span>.<br><br>
While our classic PCP Theorem was enough to show many problems had no PTAS, it is not quite as simple to use for specific lower bounds. One way to get around this limitation is to define new versions of the PCP Theorem. One such theorem was posed by Johan Hastad: <br><br>
<strong>Theorem (Hastad's 3 Bit PCP):</strong>
For every <span class="math">\(\delta &gt; 0\)</span> and <span class="math">\(L \in NP\)</span>, there exists a PCP verifier (with <span class="math">\(\mbox{log n}\)</span> bits of randomness) such that L can be verified in three queries with completeness <span class="math">\((1 - \delta)\)</span> and soundness at most <span class="math">\(\frac{1}{2}+\delta\)</span>. Furthermore the tests are of the following form. Our verifier chooses a parity bit <span class="math">\(b \in \\{0,1\\}\)</span> and then takes the three bits it queries <span class="math">\(q_1,q_2,q_3\)</span> and returns true if:
<div style="text-align:center;"></p>
<div class="math">$$ q_1 + q_2 + q_3 = b \quad (\mbox{mod } 2)$$</div>
<p></div> <br>
A full proof of this theorem is beyond the scope of this post. However we will use this theorem to show optimal inapproxibility results for MAX-3SAT as well as a more specific approximation for Vertex Cover. <br><br></p>
<p><strong>MAX-3LIN</strong><br>
The MAX-3LIN problem is defined as follows: <br>
Given a system of integral linear equations (mod 2) with a most 3 variables what is the maximum number of them which can be satisfied simultaneously? It's immediately apparent that this problem is closely related to Hastad's variant of the PCP Theorem. <br><br></p>
<p>We can consider Hastad's PCP equivalent to the statement:<br>
<p style="display:inline;">For any <span class="math">\(\epsilon &gt; 0\)</span> determining between two instance of MAX-E3LIN, one where at least <span class="math">\((1 - \epsilon)\)</span> of the equations are satisfied and one where at most <span class="math">\(\frac{1}{2}+\epsilon\)</span> of the equations are satisfied is NP-Hard.<details style="display:inline;">
    <summary>(Details)</summary>
    If we had a polynomial time algorithm to tell the difference we use it to deterministically test if any string <span class="math">\(x\)</span> is in your favorite NP-Complete language L by building a system of equations (one for each possible random string) that mimic our Hastad PCPs output given that string. If we know we satisfied more than <span class="math">\(\frac{1}{2}\)</span> of the equations, by soundness we know <span class="math">\(x\)</span> must be in <span class="math">\(L\)</span>, if we don't we know <span class="math">\(x\)</span> is not in <span class="math">\(L\)</span> by completeness. This argument is very similar to our proof that MAX-3SAT has no PTAS. 
</details><br></p>
 Now we will use this formulation to prove better approximation bounds for MAX-3SAT and Vertex Cover. We will call this problem, GAP-3LIN. The GAP part comes from the fact that the domain of all possible numbers of mutually solvable equations has a gap in the middle. In the two proofs we will exploit this gap to give better lower bounds than we would be able to obtain with just vanilla PCP.<br><br></p>
<p><strong>Theorem:</strong> MAX-3SAT cannot be approximated by a factor of <span class="math">\(1 - (\frac{7}{8}+\epsilon)\)</span> for any <span class="math">\(\epsilon &gt; 0\)</span>. <br>
To show this result we will reduce our gap GAP-E3LIN to MAX-3SAT. Given an equation:<br>
<div style="text-align:center;"></p>
<div class="math">$$ a+b+c = 0 $$</div>
<p></div>
We create the following four clauses:<br>
<div style="text-align:center;"></p>
<div class="math">$$ (\bar a\lor b \lor c) $$</div>
<p></div>
<div style="text-align:center;"></p>
<div class="math">$$ (a\lor \bar b \lor c) $$</div>
<p></div>
<div style="text-align:center;"></p>
<div class="math">$$ (a\lor b \lor \bar c) $$</div>
<p></div>
<div style="text-align:center;"></p>
<div class="math">$$ (\bar a\lor \bar b \lor \bar c) $$</div>
<p></div>
These clauses are important because all four are only satisfied if and only if <span class="math">\(a+b+c = 0\)</span> (we can do the same thing if the equation should sum to 1). Otherwise at most <span class="math">\(\frac{3}{4}\)</span> of the clauses are satisfiable. From our previous result we know that it is NP-Hard to distinguish between an instance of MAX-E3LIN where <span class="math">\(\frac{1}{2}+\delta\)</span> the equations are satisfied versus one where <span class="math">\(1-\delta\)</span> of the equations are satisfied for any <span class="math">\(\delta &gt; 0\)</span>. Consider a polynomial time algorithm Max-3SAT with an approximation ratio of <span class="math">\(\alpha\)</span>. Take an instance <span class="math">\(x\)</span> of MAX-E3LIN and creates a 3CNF expression from it by doing the following. For each equation in <span class="math">\(x\)</span> create four clauses following our above model and then combine all of them into one large 3CNF instance. If we could satisfy a fraction of more than <span class="math">\(1 - (\frac{1}{2} - \delta)\frac{1}{4}\)</span> of the clauses we could determine between the two different types of GAP-E3LIN instances. Since this is true for all <span class="math">\(\delta &gt; 0\)</span>, we know that the largest valid value of <span class="math">\(\delta\)</span> is 0 (Unless P=NP). This gives us the following lower bound for MAX-3SAT: 
<div style="text-align:center;"></p>
<div class="math">$$1 - \frac{1}{8} = \frac{7}{8}$$</div>
<p></div> <span class="math">\(\square\)</span><br></p>
<p>It turns out that the Hastad PCP Theorem is useful for more than just MAX-3SAT. Another problem which gives a specific constant bound with this theorem is vertex cover. <br><br></p>
<p><strong>Vertex Cover</strong>
Given a graph G we say that a vertex cover of G is a set of the vertices such that every vertex in the graph is directly connected to one of these vertices via and edge, The vertex cover problem is to find a minimum such vertex cover on G. <br><br></p>
<p><strong>Independent Set</strong>
It is useful to talk about independent set whenever we talk about vertex cover. Given a graph G, an Independent Set is a set of vertices which are not connected to each other. The Independent Set problem is to find the largest independent set in G. <br><br></p>
<p><strong>Fact</strong> One reason why these two problems are often presented together is because one is the complement of the other. That is to say let <span class="math">\(I\)</span> the maximum independent set in a graph and let <span class="math">\(C\)</span> the minimum vertex cover. <span class="math">\(G - I = C\)</span> (or the other way around). <br><br></p>
<p><strong>Theorem:</strong> Vertex Cover cannot be approximated within a factor of <span class="math">\(\frac{7}{6} - \epsilon\)</span> for any <span class="math">\(\epsilon &gt; 0\)</span> unless P=NP. <br><br>
We again use the fact that GAP-3LIN is NP-Hard. Our goal is to use a <span class="math">\(\frac{7}{6} - \epsilon\)</span> approximation of Vertex Cover to solve GAP-3LIN. We just need a way to translate equations to graphs. We will do this using the following construction: <br>
Look at an equation of the form <br>
<div style="text-align:center;"></p>
<div class="math">$$x_1 + x_2 + x_3 = 0 \quad \mbox{mod } 2$$</div>
<p></div>
The first thing we can notice about it is that it has eight possible choices of values. Notice that half of them will satisfy the equation and half of them will not. Therefore for any equation of this form there are 4 ways to satisfy it. <br>
Now in our graph for each equation in our MAX-E3LIN instance we will create four different vertices, one for each of the valid solutions to the equation. We will connect all of them together as well as connecting them to each other vertex in the graph representing a logically incompatible solution to a different equation. When we are done there will be <span class="math">\(4m\)</span> vertices. Here's an example with two equations<br><br></p>
<p align="center">
    <img src="/images/pcp-theorem/e3lin-to-vertex-cover.png" width="65%" > 
</p>

<p><strong>Observation 1</strong> If at least <span class="math">\((1-\epsilon)m\)</span> of the equations of our GAP-E3LIN instance are satisfiable then our independent set is at least of size <span class="math">\((1-\epsilon)m\)</span>. This is because by construction of our graph, each satisfiable equation does not have an edge to any other mutually satisfiable equations because neither of them are different variable choices for the same equation and neither contradict each other. So since the maximum independent set is at least of size <span class="math">\((1 - \epsilon)m\)</span>, the minimum vertex cover will be at most of size <span class="math">\((3 + \epsilon)m\)</span>. <br><br></p>
<p><strong>Observation 2</strong> If at most <span class="math">\((\frac{1}{2} + \epsilon)m\)</span> equations are mutually satisfiable, then our maximal independent set will be of size at most <span class="math">\((\frac{1}{2} + \epsilon)m\)</span>. To show this is true consider we will pretend we could have a larger independent set. Take <span class="math">\(v\)</span> a vertex in this independent set which does not represent one our our satisfiable equations. By the rules of our construction <span class="math">\(v\)</span> would also not conflict with any of the <span class="math">\((\frac{1}{2} + \epsilon)m\)</span> mutually satisfiable equations of the other equations represented in the independent set. Therefore the existence of <span class="math">\(v\)</span> would imply there is another equation which could be mutually satisfied. This would contradict our assume that only <span class="math">\((\frac{1}{2} + \epsilon)m\)</span> are mutually satisfiable. So we know that the maximum independent set size is at most <span class="math">\((\frac{1}{2} + \epsilon)m\)</span>. This implies that the minimum vertex cover size will be at least <span class="math">\((\frac{7}{2} - \epsilon)m\)</span>. <br><br></p>
<p>The two observations we have just made help define the gap between vertex cover instances associated with each of the two cases. This means that if we can approximate the upper bound of the smaller case within a factor that is tight enough so our approximation does not overlap with the lower bound of the larger case then we can distinguish between the two cases. To formalize this assume that we have an algorithm which can approximate vertex cover to a factor of <span class="math">\(\alpha\)</span>. For any <span class="math">\(\epsilon &gt; 0\)</span> we know that unless we can solve GAP-3LIN in polynomial time: <br>
<div style="text-align:center;"></p>
<div class="math">$$\alpha (3 + \epsilon) &gt; \frac{7}{2} - \epsilon$$</div>
<p></div>
<div style="text-align:center;"></p>
<div class="math">$$\alpha &gt; \frac{\frac{7}{2} - \epsilon}{(3 + \epsilon)}$$</div>
<p></div>
This is to say that if <span class="math">\(\alpha\)</span> is too small than our smaller case and our larger case still be distinguished in our approximation. 
Because this is true for all <span class="math">\(\epsilon &gt; 0\)</span> we can take the limit as <span class="math">\(\epsilon \to 0\)</span> to find an <span class="math">\(\alpha\)</span> that works for all cases: <br>
<div style="text-align:center;"></p>
<div class="math">$$\alpha = \frac{\frac{7}{2}}{3} = \frac{7}{6}$$</div>
<p> </div> <span class="math">\(\square\)</span><br></p>
<p><strong>Let's Play a Game</strong> <br>
Now we have seen some basic ideas such as gaps and simple graph operations as ways to prove hardness. One more common set of tools to show hardness of approximations is 2 Prover 1 Round Games. This last section aims to give some background on this problem. <br><br>
<strong>Definition:</strong> A 2 Prover 1 Round Game is a game played by two provers (players) with the following parameters: <br>
Two sets of questions: (one for each player) <span class="math">\(X,Y\)</span> <br>
A probability distribution: <span class="math">\(\lambda\)</span> over <span class="math">\(X \times Y\)</span> <br>
A set of answers: <span class="math">\(A\)</span> <br>
A verifier (acceptance predicate): <span class="math">\(V:X\times Y \times A \times A\)</span> <br>
A strategy for each player: <span class="math">\(f_1:X \to A, f_2:Y \to A\)</span> <br><br>
The rules of the game are as follows: <br>
The verifier picks two questions <span class="math">\((x, y) \in X \times Y\)</span> from the distribution and asks x to player 1 and y to the player 2. <br>
Each player thinks of an answer to their respective questions <span class="math">\((a_1,a_2)\)</span> by computing <span class="math">\(a_1 = f_1(x), a_2 = f_2(y)\)</span>. <br>
The verifier takes both answers and the original questions <span class="math">\(v(x,y,a_1,a_2)\)</span> and returns either true or false. <br><br>
The goal of both players is to maximize <span class="math">\(\omega(G)\)</span> to be the optimal win probability for the game G. <br><br>
Also it is important that the two players cannot communicate during the game. <br></p>
<p>You might be thinking, what kind of stupid game is this? Why don't computer scientists at least play something cool like fortnite?
Well here's something kind of cool. We can formulate many problems as 2 Prover 1 Round Games. Let's give an example using good old 3SAT. <br><br></p>
<p>Given a set of clauses <span class="math">\(x\)</span> in 3CNF form, consider the following 2P1R game: <br>
Let <span class="math">\(X\)</span> be the set of all clauses in <span class="math">\(x\)</span>. <br>
Let <span class="math">\(Y\)</span> be the set of all variables in <span class="math">\(x\)</span>. <br>
Let <span class="math">\(\lambda\)</span> be such the variable we draw from <span class="math">\(Y\)</span> will be in the clause drawn from <span class="math">\(X\)</span> (it will be one of the three of them with uniform probability). <br>
Our first prover will return an assignment <span class="math">\(\alpha\)</span> of variables satisfying the clause <span class="math">\(c_j\)</span> it was given. The second prover will return an assignment <span class="math">\(\beta\)</span> of <span class="math">\(x_i\)</span> the variable it was given. The verifier will return true if and only if <span class="math">\(\beta\)</span> matches the assignment given to the same variable in <span class="math">\(\alpha\)</span>. <br><br> 
Observation 1: If <span class="math">\(x\)</span> is fully satisfiable then both players just pick according to the satisfying assignment. In some cases there may be more than one satisfying assignment in which case both players can agree some sort of ordering scheme beforehand and pick the first one. <br><br>
Observation 2: If no satisfying assignment exists then every assignment fails to satisfy a certain factor of the clauses (let's call it <span class="math">\(p\)</span>). Then the probability of failure will be at least <span class="math">\(\frac{p}{3}\)</span>. <br><br>
Now there are several things that are interesting about this 2 prover round 1 game reduction. One is that we turned 3SAT which is a decision problem into a gap decision problem. The second thing which is related is that we can now start to talk about this game in terms of completeness and soundness. In a way this is starting to sound like the PCP Theorem. <br><br>
Another thing we could try is to play some kind of repeated game. One way we could do this is asking a series of questions, one after another. However it turns out to be more interesting to ask a bunch of questions at the same time (in parallel). We define a parallel n-repeated game <span class="math">\(G^n\)</span> for some 2P1R game G to be similar to G but each player reads a tuple of n questions and then outputs a tuple of n answers. The verifier accepts if and only if all the individual answers would be accepted by the verifier for G. So what can we say about these repeated games?<br><br> 
<strong>Theorem (Parallel Repetition Theorem):</strong> For all games <span class="math">\(G\)</span> if <span class="math">\(\omega(G) = 1 - \delta\)</span> then, <br>
<div style="text-align:center;"></p>
<div class="math">$$ \omega(G^n) \leq 2^{-\Omega(\delta^3 n)} $$</div>
</div>

<p>While we will not go talk about this theorem much it is interesting because it can be used to decrease the size of gaps. In our 3-SAT game it is NP-Hard to distinguish between cases where we succeed with probability 1 and probability <span class="math">\(1-\frac{p}{3}\)</span>. But what if we could make our gap smaller? This could potentially make it easier to show different approximations are hard. <br><br><br> </p>
<p><strong>Summary</strong><br>
In this post I have summarized my findings after researching the a few basic concepts surrounding the PCP Theorem. Throughout this post there are a few big ideas. First we looked at the PCP Theorem itself and the ideas of completeness and soundness. We played with a few toy cases to get a feel for what the statement was saying. Next we used the PCP Theorem to shows MAX-3SAT had no PTAS. In this proof we turned our random PCP verifier in to a deterministic instance of MAX-3SAT. Then we showed that using MAX-3SAT we could search for a proof that our statement was correct or not. We then used graphs and the self improvement property of the graph product to prove that Max Clique had no constant approximation. After that we looked at Hastad's 3 bit PCP and used it to get a few more specific bounds on MAX-3SAT and Vertex Cover. The most important part of these proofs were the gap preserving reduction from our GAP-MAX-E3LIN decision problem. Finally we looked at a totally different way of viewing everything as a game. These general proof strategies give us some tools to tackle inapproximability arguments. <br><br></p>
<p><strong>Exercises to the Reader</strong> <br><br> </p>
<p>1) Show <span class="math">\(PCP(log(n), 1) = P\)</span>
<details style="display:inline;">
    <summary>Hint</summary>
    Think about our proof that MAX-3SAT has no PTAS.
</details><br></p></p>
<details style="display:inline;">
    <summary>Answer</summary>
    <br> As a proof of this consider our reduction in the proof for MAX-3SAT having no PTAS. We constructed a MAX-3SAT instance which checked if there was a (the bits of the proof were the variables) proof which could satisfy every one of the O(n) possible combinations of our O(log(n)) bits of randomness. The key was that we only had to have a constant number of variables because we only read a constant number of bits of the proof. Furthermore the size of our clauses was based on the number of bits we read. If we do this same construction here we will end up with an instance of MAX-1SAT which is solvable in polynomial time.
    <br><br>
</details>

<p><br></p>
<p>2) We talked about MAX-E3LIN but never proved any hardness results for it. Use Hastad's PCP Theorem prove the following: <br> 
<strong>Theorem:</strong> MAX-3LIN cannot be approximated by a factor of <span class="math">\(\frac{1}{2}+\epsilon\)</span> for any <span class="math">\(\epsilon &gt; 0\)</span>. <br>
<details style="display:inline;">
    <summary>Answer</summary>
    <br> Reduce the optimization version of MAX-E3LIN to the decision version using a gap preserving reduction.
    <br><br>
</details><br></p>
<p>3) When the repeated version 2 Prover 1 Round Game was originally conceived it was conjectured that<br>
<div style="text-align:center;"></p>
<div class="math">$$\omega(G^k) = \omega(G)^k$$</div>
<p></div>
Give a 2P1R Game which shows that this is false (i.e. <span class="math">\(\omega(G^k) &gt; \omega(G)^k\)</span>)<br>
<details style="display:inline;">
    <summary>Answer</summary>
    We define the Feige Game defined as follows:<br> Each player gets a bit as input. They must output a bit and a player. The players win if their bits are the same and that player did get that bit. Because they can't communicate <span class="math">\(\omega(G) = \frac{1}{2}\)</span>. The best strategy is to agree upon a player in advance. That player will pick themselves and their bit and the other player will guess their bit. However if the players play the two round version they can double down on their original bets which would mean <span class="math">\(\omega(G^2) = \frac{1}{2}\)</span> as well.
    <br><br>
</details><br><br><br><br><br>
Sources (and great references for learning more): <br>
http://www.cs.jhu.edu/~scheideler/courses/600.471_S05/lecture_9.pdf<br>
http://people.seas.harvard.edu/~madhusudan/courses/Spring2016/scribe/lect18.pdf<br>
http://pages.cs.wisc.edu/~shuchi/courses/880-S07/scribe-notes/lecture29.pdf<br>
http://www.cs.princeton.edu/~zdvir/apx11slides/guruswami-slides.pdf<br>
https://cstheory.stackexchange.com/questions/18360/multi-prover-verifier-games-and-pcp-theorem<br>
http://theory.cs.princeton.edu/complexity/ab_hastadchap.pdf
<br><br><br><br><br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="http://getpelican.com/">Pelican</a></li>
                            <li><a href="http://python.org/">Python.org</a></li>
                            <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>